System Architecture Overview Core Components: Main Data Module - Entry point for the entire system DataStorage - Low-level data store wrapper with locking mechanisms Shared Module - Manages player data lifecycle Template System - Defines data structure Queue System - Handles async data operations How to Use the Data System 1. Basic Data Access lua local Data = require(game.ServerScriptService.Main.Data) -- Get player data (waits for data to load) local playerData = Data:Get(player) print(playerData.Level) -- Access data properties 2. Modifying Player Data lua -- Data is automatically tracked and saved local data = Data:Get(player) data.Level = data.Level + 1 data.Stats.Strength = data.Stats.Strength + 5 -- Changes are automatically persisted via the proxy system 3. Queue System for Async Operations lua -- Queue operations that need to be processed when player joins local success = Data:Queue(player.UserId, { key = "gift", info = "premium_item_123" }) -- This will trigger the gift function in QueueFunctions when player joins 4. Forced Updates lua -- Force immediate data save with custom operations Data:ForcedUpdate(player.UserId, function(previousData) -- Custom logic here return modifiedData end, { key = "special_event", info = eventData }) Data Structure (Template) The system uses this template structure: lua { id = "1", Name = "DefaultName", Race = "RealitySeed", Stage = "Fledgeling", Level = 1, Stats = { Hp = 100, Strength = 10, Defense = 10, -- ... other stats }, Moves = {"BasicAttack"}, Appearance = {}, History = {"RealitySeed"} } Key Features üîí Automatic Concurrency Control Uses MemoryStore for distributed locking Prevents data conflicts between servers Automatic retry mechanisms üíæ Smart Persistence Automatic saving on intervals (configurable) Save-on-close functionality Compression to reduce data store usage Change tracking via proxy system üîÑ Queue Processing Handles operations for offline players Processes queued actions on player join Example: Delivering gifts while player was offline üõ°Ô∏è Error Handling & Recovery Automatic retry on data store failures State management for data loading Graceful handling of player disconnections Advanced Usage Custom OnJoining/OnLeaving Logic Add functions to OnJoining or OnLeaving modules: lua -- In OnJoining module return { function(plr, data) -- Custom join logic if data.Value.LastLogin then local timeSince = os.time() - data.Value.LastLogin -- Handle returning player bonuses end data.Value.LastLogin = os.time() end, -- Add more functions as needed } Adding Queue Functions Extend QueueFunctions module: lua return { gift = function(plr, info) _G.PRODUCTS[info].fun(plr, true) end, currency = function(plr, info) local data = Data:Get(plr) data.Currency = (data.Currency or 0) + info.amount end, item = function(plr, info) -- Add item to player inventory end } Configuration Modify .ENV for different environments: lua return { MainDataKey = 'production-01' -- Change for production } Best Practices Always use Data:Get(player) - Never access data stores directly Modify data through the proxy - Changes are automatically tracked Use queues for offline operations - Don't modify data directly for offline players Handle errors gracefully - The system provides retry mechanisms Monitor data usage - Use the Usage() method to check size limits Error Handling lua local success, data = pcall(function() return Data:Get(player) end) if success then -- Use data else -- Handle error (player might be leaving) end This system provides enterprise-grade data management with built-in safety mechanisms, making it suitable for production games with complex data requirements.
